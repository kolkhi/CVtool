//
// "$Id: renderer_panel.fl 02 2018-03-29 18:21:11Z gsergia $"
//
// FLUID template support for the Fast Light Tool Kit (FLTK).
//
// Copyright 1998-2016 by Bill Spitzak and others.
//
// This library is free software. Distribution and use rights are outlined in
// the file "COPYING" which should have been included with this file.  If this
// file is missing or damaged, see the license at:
//
//     http://www.fltk.org/COPYING.php
//
// Please report all bugs and problems on the following page:
//
//     http://www.fltk.org/str.php
//

// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "render_panel.h"
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <FL/filename.H>
#include <FL/fl_ask.H>
#include <FL/Fl_Shared_Image.H>
#include <FL/Fl_Preferences.H>
#include <uavv_wrapper.h>
#include <ui_controller.h>

#if defined(WIN32) && !defined(__CYGWIN__)
#include <io.h>
#else
#include <unistd.h>
#endif // WIN32 && !__CYGWIN__
extern Fl_Preferences fluid_prefs;

using namespace cvtool;
using namespace uavv;

/**
 Window for rendering
*/

RenderWnd::RenderWnd(int W, int H, const char* l)    
            : Fl_Gl_Window(W, H, l), mpFrame(nullptr)
{
    mode(FL_DOUBLE);
    resizable(this);
}

void RenderWnd::CleanUp()
{
    std::lock_guard<std::mutex> lock(imageMutex);
    IUAVVInterface::DestroyImageHandle(mpFrame);
    mpFrame = nullptr;
}

void RenderWnd::SetUIController(UIController* controller)
{
    pController = controller;
}

void RenderWnd::UpdateGLFrame(const UAVV_IMAGE buf)
{
    // Keep a reference to the frame buffer
    if (!buf) 
        return;
    
    std::lock_guard<std::mutex> lock(imageMutex);
    
    IUAVVInterface::DestroyImageHandle(mpFrame);
    mpFrame = IUAVVInterface::CopyImageHandle(buf);
    
    // Schedule a redraw
    redraw();
}


void RenderWnd::draw()
{
    if (!valid())  
      ortho();

    std::lock_guard<std::mutex> lock(imageMutex);
    
    // Update GL frame
    if (mpFrame)
    {
        mGlFrame.copy(mpFrame);
    }

    if (!mGlFrame.isValid())  
    {
        return;
    }    

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    // Fit GL frame to window
    float scale_x = w() / (float)mGlFrame.width();
    float scale_y = h() / (float)mGlFrame.height();
    
    glPushMatrix();
    glScalef(scale_x, scale_y, 1.0);
    
    mGlFrame.draw();

    glPopMatrix();
    glDisable(GL_BLEND);

    pController->UpdatePlayerControls();
}

UAVV_IMAGE RenderWnd::GetCurrentFrameCopy()
{
    if (!mpFrame) 
        return nullptr;
    
    std::lock_guard<std::mutex> lock(imageMutex);
    UAVV_IMAGE bufCopy = IUAVVInterface::CopyImageHandle(mpFrame);
    return bufCopy;
}

int RenderWnd::handle(int event) 
{
    switch(event) 
    {
    case FL_PUSH:
        {
            //... mouse down event ...
            //... position in Fl::event_x() and Fl::event_y()
            if (!valid())  
            {
                ortho();
                valid(1);
            }

            float xpos_scaled =  (float)Fl::event_x() / (float)w();
            float ypos_scaled =  (float)(h() - Fl::event_y()) / (float)h();
            pController->OnRenderMouseDown(event, xpos_scaled, ypos_scaled);
        }
        return 1;
    /*
    case FL_RELEASE:   
        ... mouse up event ...
        return 1;
    case FL_DRAG:
        ... mouse moved while down event ...
        return 1;
    case FL_FOCUS :
    case FL_UNFOCUS :
        ... Return 1 if you want keyboard events, 0 otherwise
        return 1;
    case FL_KEYBOARD:
        ... keypress, key is in Fl::event_key(), ascii in Fl::event_text()
        ... Return 1 if you understand/use the keyboard event, 0 otherwise...
        return 1;
    case FL_SHORTCUT:
        ... shortcut, key is in Fl::event_key(), ascii in Fl::event_text()
        ... Return 1 if you understand/use the shortcut event, 0 otherwise...
        return 1;
    */
    default:
        // pass other events to the base class...
        return Fl_Gl_Window::handle(event);
    }
}

//
// End of "$Id: renderer_panel.fl 02 2018-03-29 18:21:11Z gsergia $".
//
